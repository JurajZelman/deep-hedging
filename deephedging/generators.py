"""A module that contains generators of stochastic processes."""

from abc import ABC, abstractmethod
from typing import Iterator

import numpy as np
import torch


class PathGenerator(ABC):
    """Abstract base class for generators of stochastic process paths."""

    @abstractmethod
    def __init__(self) -> None:
        """Initializes the path generator."""
        pass

    @abstractmethod
    def __iter__(self) -> Iterator:
        """Returns the path generator as an iterator."""
        pass

    @abstractmethod
    def __next__(self) -> torch.Tensor:
        """Generates the next batch of paths."""
        pass


class BlackScholesGenerator(PathGenerator):
    """
    Iterator for generating batches of Brownian motion paths.

    Args:
        S0: Initial stock price.
        r: Risk-free interest rate.
        sigma: Volatility.
        T: Time horizon.
        N: Number of time steps.
        batch_size: Number of paths in each batch.
        num_batches: Number of batches to generate.
        device: Device to store the generated paths on.

    Returns:
        A batch of Brownian motion paths of shape (batch_size, N + 1).
    """

    def __init__(
        self,
        S0: float,
        r: float,
        sigma: float,
        T: int,
        N: int,
        batch_size: int,
        num_batches: int,
        device: torch.device,
    ) -> None:
        self.S0 = S0
        self.r = r
        self.sigma = sigma
        self.T = T
        self.N = N
        self.batch_size = batch_size
        self.dt = T / N
        self.num_batches = num_batches
        self.device = device

        self.batch_count = 0

    def __iter__(self) -> Iterator:
        return self

    def __next__(self) -> torch.Tensor:
        """
        Generates the next batch of Brownian motion paths.

        Returns:
            A batch of Brownian motion paths of shape (batch_size, N + 1).
        """
        if self.batch_count == self.num_batches:
            raise StopIteration
        self.batch_count += 1

        logS = np.zeros((self.N + 1, self.batch_size))
        logS[1:,] = (
            self.r - 0.5 * (self.sigma**2)
        ) * self.dt + self.sigma * np.sqrt(self.dt) * np.random.normal(
            loc=0.0, scale=1.0, size=(self.N, self.batch_size)
        )
        logS = np.cumsum(logS, axis=0)

        paths = self.S0 * np.exp(logS).T
        # return torch.from_numpy(paths).type(torch.float32).to(self.device)
        return torch.from_numpy(paths).type(torch.float32).to(self.device)


class HestonGenerator(PathGenerator):
    """
    Iterator for generating batches of paths from the Heston stochastic
    volatility paths.

    Args:
        S0: Initial stock price.
        r: Risk-free interest rate.
        theta: Long-term mean of the volatility process.
        kappa: Mean reversion speed of the volatility process.
        xi: Volatility of volatility.
        rho: Correlation between the Brownian motions.
        T: Time horizon.
        N: Number of time steps.
        batch_size: Number of paths in each batch.
        num_batches: Number of batches to generate.
        device: Device to store the generated paths on.

    Returns:
        A batch of Heston paths of shape (batch_size, N + 1).
    """

    def __init__(
        self,
        S0: float,
        v0: float,
        r: float,
        theta: float,
        kappa: float,
        xi: float,
        rho: float,
        T: int,
        N: int,
        batch_size: int,
        num_batches: int,
        device: torch.device,
    ) -> None:
        self.S0 = S0
        self.v0 = v0
        self.r = r
        self.theta = theta
        self.kappa = kappa
        self.xi = xi
        self.rho = rho
        self.T = T
        self.N = N
        self.batch_size = batch_size
        self.dt = T / N
        self.num_batches = num_batches
        self.device = device

        self.batch_count = 0

    def __iter__(self):
        return self

    def __next__(self) -> torch.Tensor:
        """
        Generates the next batch of Heston paths.

        Returns:
            A batch of Heston paths of shape (batch_size, N + 1).
        """
        if self.batch_count == self.num_batches:
            raise StopIteration
        self.batch_count += 1

        # Heston Model Paths generated by two Brownian Motions
        dt = self.T / self.N
        size = (self.batch_size, self.N + 1)
        prices = np.zeros(size)
        vols = np.zeros(size)
        S_t = self.S0
        v_t = self.v0
        prices[:, 0] = S_t
        vols[:, 0] = v_t
        for t in range(1, self.N + 1):
            W_t = np.random.multivariate_normal(
                np.array([0, 0]),
                cov=np.array([[1, self.rho], [self.rho, 1]]),
                size=self.batch_size,
            ) * np.sqrt(dt)

            S_t = S_t * (
                np.exp((self.r - v_t / 2) * dt + np.sqrt(v_t) * W_t[:, 0])
            )
            v_t = np.abs(
                v_t
                + self.kappa * (self.theta - v_t) * dt
                + self.xi * np.sqrt(v_t) * W_t[:, 1]
            )
            prices[:, t] = S_t
            vols[:, t] = v_t

        return torch.from_numpy(prices).type(torch.FloatTensor).to(self.device)
